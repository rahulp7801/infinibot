import discordfrom discord import FFmpegPCMAudioimport pylastfrom discord.ext import commandsimport modulesimport youtube_dlimport urllib.requestfrom modules import utilsimport reimport requestsimport asyncioimport datetimefrom pymongo import MongoClientimport lastpyfrom modules.music import eventmusic = modules.music.Music()with open('./mongourl.txt', 'r') as file:    url = file.read()mongo_url = url.strip()cluster = MongoClient(mongo_url)with open('lfapi.txt', 'r') as f:    key = f.read()SECRET = '3fc2809a9fc31fed3ea94864398cdd1b'class Music(commands.Cog):    def __init__(self, client):        self.client = client        self.icon = 'üéµ'        self.description = "Music in VC and **scrobbling support!**"    @staticmethod    @event.on("songstart")    def _start_scrobble_song(ctx, song):        print(song.name)        loop = ctx.bot.loop        embed = discord.Embed(color = discord.Color.blurple())        voice_client = discord.utils.get(ctx.bot.voice_clients, guild=ctx.guild)        voice_channel = voice_client.channel        count = 0        for i in voice_channel.members:            if not i.bot:                db = cluster["LASTFM"]                col = db["usernames"]                if col.count_documents({'_id':i.id}) != 0:                    count += 1        if count == 0:            return        o = (song.name).lower().replace(')', '').replace('(', '').replace('lyrics', '').replace('official', '').replace('video', '').replace('directed by cole bennett', '').replace('music', '').replace('[', '').replace(']', '').strip()        params = {            'limit': 1,            'track': (song.name).lower().replace(')', '').replace('(', '').replace('lyrics', '').replace('official', '').replace('video', '').replace('directed by cole bennett', '').replace('music', '').replace('[', '').replace(']', '').strip(),   # lol            'api_key': '35722626b405419c84e916787e6bf949',            'method': 'track.search',            'format': 'json'        }        data = requests.get(url='https://ws.audioscrobbler.com/2.0/', params=params)        data = data.json()        print(data)        if int(data["results"]["opensearch:totalResults"]) != 0:            embed.description = f"Scrobbling **{song.name}** for {count} user{'' if count == 1 else 's'}"            loop.create_task(ctx.send(embed=embed))        print("success")    @staticmethod    @event.on("songend") #event listener triggered from the module i created    def _scrobble_song(ctx, song):        print('here as welll huhua')        assert song.duration > 30 and song.duration != '', "Song not long enough to scrobble or is a live youtube video"        voice_client = discord.utils.get(ctx.bot.voice_clients, guild=ctx.guild)        voice_channel = voice_client.channel        params = {            'limit': 1,            'track': (song.name).lower().replace(')', '').replace('(', '').replace('lyrics', '').replace('official', '').replace('video', '').replace('directed by cole bennett', '').replace('music', '').replace('[', '').replace(']', '').strip(),   # lol            'api_key': '35722626b405419c84e916787e6bf949',            'method': 'track.search',            'format': 'json'        }        data = requests.get(url='https://ws.audioscrobbler.com/2.0/', params=params)        data = data.json()        if int(data["results"]["opensearch:totalResults"]) == 0:            return        for i in voice_channel.members:            if not i.bot:                db = cluster["LASTFM"]                col = db["usernames"]                if col.count_documents({'_id':i.id}) != 0:                    res = col.find({'_id':i.id})                    for k in res:                        try:                            network = pylast.LastFMNetwork(                                api_key=key,                                api_secret=SECRET,                                session_key=k["sessionkey"]                            )                            network.scrobble(title=data["results"]["trackmatches"]["track"][0]["name"],                                             artist=data["results"]["trackmatches"]["track"][0]["artist"],                                             timestamp=datetime.datetime.utcnow())                        except Exception as e:                            print(e)                            continue    @commands.command(help='Makes the bot join a voice channel.')    async def join(self, ctx):        if ctx.author.voice.channel is None:            return (False, "You must be connected to a voice channel!")        res = utils.vcperms(ctx.author.voice.channel)        if not res:            return (False, f"I am missing permissions to connect to {ctx.author.voice.channel.mention}")        try:            await ctx.author.voice.channel.connect()        except discord.Forbidden:            return (False, "I cannot connect to this Voice Channel!")        except Exception as e:            return (False, e)        return await ctx.send(f"Connected to `{ctx.author.voice.channel.name}`")    @commands.command(aliases = ['dc', 'disconnect'], help='Makes the bot leave a voice channel.')    async def leave(self, ctx):        try:            player = music.get_player(guild_id=ctx.guild.id)            if player:                player.delete()            await ctx.voice_client.disconnect()            await ctx.message.add_reaction('üëãüèΩ')        except:            pass    @commands.command(help='Plays a song.') #add lfm integration, should be pretty easy from here    async def play(self, ctx, *, query):        if not ctx.guild.me.voice:            res = await self.join(ctx)            if not res:                return await ctx.send(res[1])        # if not ctx.guild.me.voice:        #     return await ctx.send("I am not in a voice channel!")        embed = discord.Embed(color = discord.Color.green())        try:            await ctx.send('Searching for `{url}`...'.format(url=query.strip()))            if ('www.' or '.be' or '.com' or 'youtu') not in query.lower():                query = query.strip().replace(' ', '+').replace("'", '%27').replace('&', '%26').replace('^', '%5E').replace('%', '%25').replace(':', '%3A').replace(';', '%3B')                html = urllib.request.urlopen(f"https://www.youtube.com/results?search_query={query}")                vidid = re.findall(r"watch\?v=(\S{11})", html.read().decode())                query = (f"https://www.youtube.com/watch?v={vidid[0]}")            player = music.get_player(guild_id=ctx.guild.id)            if not player:                player = music.create_player(ctx, ffmpeg_error_betterfix=True)            if not ctx.voice_client.is_playing():                await player.queue(query.strip(), requester=ctx.author,search=True)                song = await player.play()                embed.set_author(name='Now Playing', icon_url=ctx.author.avatar_url)            else:                song = await player.queue(query.strip(), requester = ctx.author, search=True)                embed.set_author(name='Added to Queue', icon_url=ctx.author.avatar_url)            dur = song.duration            dur = utils.stringfromtime(int(dur))            print(dur)            embed.add_field(name='Duration', value=f"{dur if dur != '' else 'Live'}")            embed.add_field(name='Channel', value=f"{song.channel}")            embed.description = f"[{song.name}]({song.url})"            embed.set_thumbnail(url=song.thumbnail)            await ctx.send(embed=embed)        except Exception as e:            print(e)    @commands.command(help='Pauses a song.')    async def pause(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        song = await player.pause()        await ctx.send(f"‚è∏ Paused: **{song.name}**!")    @commands.command(aliases = ['unpause'], help='Resumes a song.')    async def resume(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        song = await player.resume()        await ctx.send(f"‚ñ∂ Resumed: **{song.name}**")    @commands.command(help='Toggles loop for a track')    async def loop(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        song = await player.toggle_song_loop()        if song.is_looping:            await ctx.send(f"‚ôæ Enabled loop for: **{song.name}**")        else:            await ctx.send(f"‚ôæ Disabled loop for: **{song.name}**")    @commands.command(help='Prints the queue.')    async def queue(self, ctx):        q = []        player = music.get_player(guild_id=ctx.guild.id)        i = 0        if player.current_queue():            for song in player.current_queue():                i += 1                dur = song.duration                dur = utils.stringfromtime(int(dur))                q.append(f"{i}. {song.name} | {dur}")            qlen = len(player.current_queue())            fin = "\n"+ "\n".join(q) + f"\n\n{qlen} song{'' if qlen == 1 else 's'}"            await ctx.send(f"```py"                           f"{fin}```")        else:            return await ctx.reply(f"Nothing is playing right now! Use `{ctx.prefix}play` to get me in a voice channel!", mention_author = False)    @commands.command(aliases = ['nowplaying'], help='Get the track that is playing!')    async def np(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        song = player.now_playing()        if song is None:            return await ctx.send(f"Nothing is playing right now! Use `{ctx.prefix}join` to get me in a VC!")        await ctx.send('Now Playing : **' + song.name + '**')    @commands.command(aliases = ['s', 'seek'], help='Skip the current song.')    async def skip(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        data = await player.skip(requester = ctx.author, force=True)        await ctx.send(f"Skipped **{data[0].name}**.")    @commands.command(help='Removes a song from the queue.')    async def remove(self, ctx, index):        player = music.get_player(guild_id=ctx.guild.id)        try:            song = await player.remove_from_queue((int(index) - 1))        except:            return await ctx.send("Are you sure you specified a correct number?")        await ctx.send(f"Removed `{song.name}` from queue!")    @commands.command(help='Shuffles the queue.')    async def shuffle(self, ctx):        player = music.get_player(guild_id=ctx.guild.id)        try:            player.shuffle()            await ctx.message.add_reaction('üëçüèΩ')        except:            return await ctx.send("There is nothing in queue :(")    @commands.command(help='Get a random radio channel!') #works    async def radio(self, ctx, *, genre='random'):        if genre.lower() in ('mellow'):            url = 'https://stream.radioparadise.com/mellow-192'        elif genre.lower() in ('rock'):            url = 'http://stream.radioparadise.com/rock-128'        elif genre.lower() in ('world'):            url='https://stream.radioparadise.com/world-etc-192'        elif genre.lower() in ('main'):            url='https://stream.radioparadise.com/mp3-320'        else:            return await ctx.send(f"{genre.title()} is unsupported.\n\nWe have `Mellow`, `Rock`, `World`, and `Main`.")        await ctx.send(f"Choosing a {genre} genre...")        try:            channel = ctx.author.voice.channel            player = await channel.connect()            print('oooo')            player.play(FFmpegPCMAudio(url))        except Exception as e:            print(e)def setup(client):    client.add_cog(Music(client))